#!/bin/bash

# 默认目录
SLIMY_DIR_SYSTEM="/usr/share/gxde-k9/slimy/"
TIMER_DIR_SYSTEM="/usr/share/gxde-k9/timer/"
SLIMY_DIR_USER="$HOME/.local/share/GXDE/gxde-k9/slimy/"
TIMER_DIR_USER="$HOME/.local/share/GXDE/gxde-k9/timer/"
PID_DIR="/tmp/GXDE/gxde-k9/$UID/"
LOCKFILE="${PID_DIR}/gxde-k9-daemon.lock"

# 打印帮助信息
print_help() {
    cat << EOF
Usage: $0 [options]

Options:
  --slimy-dir <path>   Specify the directory to monitor for .slimy scripts.
  --timer-dir <path>   Specify the directory to monitor for .timer files.
  --pid-dir <path>     Specify the location for the PID DIR.
  -h                   Show this help message and exit.

Description:
  K9 Lick Daemon gen 2 monitors a specified directory for .slimy scripts
  and executes them. It also supports .timer files with crontab-like schedules.
  By default, it monitors $SLIMY_DIR_SYSTEM and $TIMER_DIR_SYSTEM, as well as
  user-specific directories: $SLIMY_DIR_USER and $TIMER_DIR_USER.

Timer Example:
* * * * * <command>
- - - - -
| | | | |
| | | | +----- Day of week (0 - 7) (Sunday=0 or 7)
| | | +------- Month (1 - 12)
| | +--------- Day of month (1 - 31)
| +----------- Hour (0 - 23)
+------------- Minute (0 - 59)


EOF
    exit 0
}

# 防止多次运行，带 PID 校验
check_lockfile() {
    if [[ -f "$LOCKFILE" ]]; then
        existing_pid=$(cat "$LOCKFILE")
        if [[ -n "$existing_pid" && -e "/proc/$existing_pid" ]]; then
            echo "Daemon is already running with PID $existing_pid. Exiting."
            exit 1
        else
            echo "Stale lockfile detected. Removing lockfile and continuing."
            rm -f "$LOCKFILE"
        fi
    fi
}

# 创建锁文件
create_lockfile() {
    mkdir -p "$(dirname "$LOCKFILE")"
    echo $$ > "$LOCKFILE"
}

# 删除锁文件
remove_lockfile() {
    rm -f "$LOCKFILE"
    exit 0
}

# 解析命令行参数
while [[ $# -gt 0 ]]; do
    case $1 in
        --slimy-dir)
            shift
            if [[ -z "$1" ]]; then
                echo "Error: --slimy-dir requires a directory path."
                exit 1
            fi
            SLIMY_DIR="$1"
            ;;
        --timer-dir)
            shift
            if [[ -z "$1" ]]; then
                echo "Error: --timer-dir requires a directory path."
                exit 1
            fi
            TIMER_DIR="$1"
            ;;
        --pid-dir)
            shift
            if [[ -z "$1" ]]; then
                echo "Error: --pid-dir requires a directory path."
                exit 1
            fi
            PID_DIR="$1"
            LOCKFILE="$1/gxde-k9-daemon.lock"
            ;;
        -h|--help)
            print_help
            ;;
        *)
            echo "Unknown option: $1"
            print_help
            ;;
    esac
    shift
done

# 使用用户指定的目录或默认目录
export SLIMY_DIR="$SLIMY_DIR_SYSTEM"
export TIMER_DIR="$TIMER_DIR_SYSTEM"

if [[ -d "$SLIMY_DIR_USER" ]]; then
    SLIMY_DIR="$SLIMY_DIR_USER"
fi
if [[ -d "$TIMER_DIR_USER" ]]; then
    TIMER_DIR="$TIMER_DIR_USER"
fi

export SLIMY_DIR
export TIMER_DIR
export PID_DIR
export LOCKFILE

# 检查并创建锁文件
check_lockfile
trap remove_lockfile SIGINT SIGTERM
create_lockfile

# 确保目录存在
if [[ ! -d "$SLIMY_DIR" ]]; then
    echo "Error: Slimy directory $SLIMY_DIR does not exist!"
    remove_lockfile
fi

if [[ ! -d "$TIMER_DIR" ]]; then
    echo "Error: Timer directory $TIMER_DIR does not exist!"
    remove_lockfile
fi

# 输出启动信息
echo "--------------------------------------------------------------"
echo "K9 Lick Daemon gen 2 is ready"
echo "I am $(whoami)"
echo "Watching slimy orders at $SLIMY_DIR and $SLIMY_DIR_USER"
echo "Monitoring timers at $TIMER_DIR and $TIMER_DIR_USER"
echo "Lockfile location: $LOCKFILE"
echo "--------------------------------------------------------------"

# 运行所有 .slimy 脚本
run_slimy_scripts() {
    # 在两个目录中查找 .slimy 文件并执行
    find "$SLIMY_DIR" -name "*.slimy" -exec bash -c '{}' \; &
    find "$SLIMY_DIR_USER" -name "*.slimy" -exec bash -c '{}' \; &
}

# 解析 crontab-like 格式的定时器时间 (支持完整的 cron 语法)
is_cron_time_matched() {
    local cron_time="$1"
    local minute hour day month weekday

    # 将 cron 表达式分解成时间字段
    read -r minute hour day month weekday <<< "$(echo "$cron_time" | tr ' ' '\n')"
    
    # 获取当前的时间值
    local current_minute=$(date +'%M')
    local current_hour=$(date +'%H')
    local current_day=$(date +'%d')
    local current_month=$(date +'%m')
    local current_weekday=$(date +'%u') # 1=Monday ... 7=Sunday

    # 检查分钟字段
    if ! matches_cron_field "$minute" "$current_minute"; then return 1; fi

    # 检查小时字段
    if ! matches_cron_field "$hour" "$current_hour"; then return 1; fi

    # 检查日期字段
    if ! matches_cron_field "$day" "$current_day"; then return 1; fi

    # 检查月份字段
    if ! matches_cron_field "$month" "$current_month"; then return 1; fi

    # 检查星期几字段
    if ! matches_cron_field "$weekday" "$current_weekday"; then return 1; fi

    # 如果所有字段都匹配，则返回 true
    return 0
}

# 处理 cron 字段是否匹配
matches_cron_field() {
    local field="$1"
    local current_value="$2"

    if [[ "$field" == "*" ]]; then
        return 0  # 匹配所有值
    elif [[ "$field" == */* ]]; then
        # 如果是 "*/x" 的形式，例如 "*/5"，表示每 x 个单位匹配一次
        local step
        step=$(echo "$field" | cut -d'/' -f2)
        if (( current_value % step == 0 )); then
            return 0
        fi
    elif [[ "$field" == "$current_value" ]]; then
        return 0  # 完全匹配
    elif [[ "$field" == *"-"* ]]; then
        # 如果是范围形式，例如 "1-5" 表示匹配 1 到 5
        local start end
        start=$(echo "$field" | cut -d'-' -f1)
        end=$(echo "$field" | cut -d'-' -f2)
        if (( current_value >= start && current_value <= end )); then
            return 0
        fi
    elif [[ "$field" == *","* ]]; then
        # 如果是逗号分隔的多个值，例如 "1,2,5"
        IFS=',' read -ra values <<< "$field"
        for value in "${values[@]}"; do
            if [[ "$value" == "$current_value" ]]; then
                return 0
            fi
        done
    fi

    return 1  # 不匹配
}

# 运行 @reboot 任务
run_reboot_tasks() {
    while true; do
        for timer_file in "$TIMER_DIR"/*.timer "$TIMER_DIR_USER"/*.timer; do
            [[ -e "$timer_file" ]] || continue
            while IFS= read -r line; do
                schedule=$(echo "$line" | cut -d'|' -f1)
                command=$(echo "$line" | cut -d'|' -f2)
                
                # 处理 @reboot 特殊规则
                if [[ "$schedule" == "@reboot" ]]; then
                    echo "$(date +'%Y-%m-%d %H:%M:%S') - Running reboot task: $command"
                    bash -c "$command" &
                fi
            done < "$timer_file"
        done
        sleep 60
    done
}

# 监控 timer 文件并执行任务
monitor_timers() {
    while true; do
        for timer_file in "$TIMER_DIR"/*.timer "$TIMER_DIR_USER"/*.timer; do
            [[ -e "$timer_file" ]] || continue
            while IFS= read -r line; do
                schedule=$(echo "$line" | cut -d'|' -f1)
                command=$(echo "$line" | cut -d'|' -f2)
                
                # 如果 crontab 格式匹配当前时间
                if is_cron_time_matched "$schedule"; then
                    echo "$(date +'%Y-%m-%d %H:%M:%S') - Running scheduled task: $command"
                    bash -c "$command" &
                fi
            done < "$timer_file"
        done
        sleep 60
    done
}



# 启动 slimy 监控 (每5秒执行一次)
watch_slimy_scripts() {
    while true; do
        run_slimy_scripts
        sleep 5
    done
}

# 启动 slimy 
watch_slimy_scripts &
# 启动 @reboot 任务
run_reboot_tasks &
# 启动定时任务监控
monitor_timers &

wait
